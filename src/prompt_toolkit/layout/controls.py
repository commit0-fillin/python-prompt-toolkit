"""
User interface Controls for the layout.
"""
from __future__ import annotations
import time
from abc import ABCMeta, abstractmethod
from typing import TYPE_CHECKING, Callable, Hashable, Iterable, NamedTuple
from prompt_toolkit.application.current import get_app
from prompt_toolkit.buffer import Buffer
from prompt_toolkit.cache import SimpleCache
from prompt_toolkit.data_structures import Point
from prompt_toolkit.document import Document
from prompt_toolkit.filters import FilterOrBool, to_filter
from prompt_toolkit.formatted_text import AnyFormattedText, StyleAndTextTuples, to_formatted_text
from prompt_toolkit.formatted_text.utils import fragment_list_to_text, fragment_list_width, split_lines
from prompt_toolkit.lexers import Lexer, SimpleLexer
from prompt_toolkit.mouse_events import MouseButton, MouseEvent, MouseEventType
from prompt_toolkit.search import SearchState
from prompt_toolkit.selection import SelectionType
from prompt_toolkit.utils import get_cwidth
from .processors import DisplayMultipleCursors, HighlightIncrementalSearchProcessor, HighlightSearchProcessor, HighlightSelectionProcessor, Processor, TransformationInput, merge_processors
if TYPE_CHECKING:
    from prompt_toolkit.key_binding.key_bindings import KeyBindingsBase, NotImplementedOrNone
    from prompt_toolkit.utils import Event
__all__ = ['BufferControl', 'SearchBufferControl', 'DummyControl', 'FormattedTextControl', 'UIControl', 'UIContent']
GetLinePrefixCallable = Callable[[int, int], AnyFormattedText]

class UIControl(metaclass=ABCMeta):
    """
    Base class for all user interface controls.
    """

    def is_focusable(self) -> bool:
        """
        Tell whether this user control is focusable.
        """
        return False

    @abstractmethod
    def create_content(self, width: int, height: int) -> UIContent:
        """
        Generate the content for this user control.

        Returns a :class:`.UIContent` instance.
        """
        raise NotImplementedError("Subclasses should implement this method")

    def mouse_handler(self, mouse_event: MouseEvent) -> NotImplementedOrNone:
        """
        Handle mouse events.

        When `NotImplemented` is returned, it means that the given event is not
        handled by the `UIControl` itself. The `Window` or key bindings can
        decide to handle this event as scrolling or changing focus.

        :param mouse_event: `MouseEvent` instance.
        """
        return NotImplemented

    def move_cursor_down(self) -> None:
        """
        Request to move the cursor down.
        This happens when scrolling down and the cursor is completely at the
        top.
        """
        # Default implementation does nothing

    def move_cursor_up(self) -> None:
        """
        Request to move the cursor up.
        """
        # Default implementation does nothing

    def get_key_bindings(self) -> KeyBindingsBase | None:
        """
        The key bindings that are specific for this user control.

        Return a :class:`.KeyBindings` object if some key bindings are
        specified, or `None` otherwise.
        """
        return None

    def get_invalidate_events(self) -> Iterable[Event[object]]:
        """
        Return a list of `Event` objects. This can be a generator.
        (The application collects all these events, in order to bind redraw
        handlers to these events.)
        """
        return []

class UIContent:
    """
    Content generated by a user control. This content consists of a list of
    lines.

    :param get_line: Callable that takes a line number and returns the current
        line. This is a list of (style_str, text) tuples.
    :param line_count: The number of lines.
    :param cursor_position: a :class:`.Point` for the cursor position.
    :param menu_position: a :class:`.Point` for the menu position.
    :param show_cursor: Make the cursor visible.
    """

    def __init__(self, get_line: Callable[[int], StyleAndTextTuples]=lambda i: [], line_count: int=0, cursor_position: Point | None=None, menu_position: Point | None=None, show_cursor: bool=True):
        self.get_line = get_line
        self.line_count = line_count
        self.cursor_position = cursor_position or Point(x=0, y=0)
        self.menu_position = menu_position
        self.show_cursor = show_cursor
        self._line_heights_cache: dict[Hashable, int] = {}

    def __getitem__(self, lineno: int) -> StyleAndTextTuples:
        """Make it iterable (iterate line by line)."""
        if lineno < self.line_count:
            return self.get_line(lineno)
        else:
            raise IndexError

    def get_height_for_line(self, lineno: int, width: int, get_line_prefix: GetLinePrefixCallable | None, slice_stop: int | None=None) -> int:
        """
        Return the height that a given line would need if it is rendered in a
        space with the given width (using line wrapping).

        :param get_line_prefix: None or a `Window.get_line_prefix` callable
            that returns the prefix to be inserted before this line.
        :param slice_stop: Wrap only "line[:slice_stop]" and return that
            partial result. This is needed for scrolling the window correctly
            when line wrapping.
        :returns: The computed height.
        """
        line = self.get_line(lineno)
        line_text = fragment_list_to_text(line)
        
        # Calculate the length of the prefix
        prefix_length = 0
        if get_line_prefix:
            prefix = get_line_prefix(lineno, 0)
            prefix_length = fragment_list_width(prefix)
        
        # Calculate the effective width (considering the prefix)
        effective_width = width - prefix_length
        
        # Apply slice_stop if provided
        if slice_stop is not None:
            line_text = line_text[:slice_stop]
        
        # Calculate the number of wrapped lines
        wrapped_line_count = (len(line_text) + effective_width - 1) // effective_width
        
        return max(1, wrapped_line_count)

class FormattedTextControl(UIControl):
    """
    Control that displays formatted text. This can be either plain text, an
    :class:`~prompt_toolkit.formatted_text.HTML` object an
    :class:`~prompt_toolkit.formatted_text.ANSI` object, a list of ``(style_str,
    text)`` tuples or a callable that takes no argument and returns one of
    those, depending on how you prefer to do the formatting. See
    ``prompt_toolkit.layout.formatted_text`` for more information.

    (It's mostly optimized for rather small widgets, like toolbars, menus, etc...)

    When this UI control has the focus, the cursor will be shown in the upper
    left corner of this control by default. There are two ways for specifying
    the cursor position:

    - Pass a `get_cursor_position` function which returns a `Point` instance
      with the current cursor position.

    - If the (formatted) text is passed as a list of ``(style, text)`` tuples
      and there is one that looks like ``('[SetCursorPosition]', '')``, then
      this will specify the cursor position.

    Mouse support:

        The list of fragments can also contain tuples of three items, looking like:
        (style_str, text, handler). When mouse support is enabled and the user
        clicks on this fragment, then the given handler is called. That handler
        should accept two inputs: (Application, MouseEvent) and it should
        either handle the event or return `NotImplemented` in case we want the
        containing Window to handle this event.

    :param focusable: `bool` or :class:`.Filter`: Tell whether this control is
        focusable.

    :param text: Text or formatted text to be displayed.
    :param style: Style string applied to the content. (If you want to style
        the whole :class:`~prompt_toolkit.layout.Window`, pass the style to the
        :class:`~prompt_toolkit.layout.Window` instead.)
    :param key_bindings: a :class:`.KeyBindings` object.
    :param get_cursor_position: A callable that returns the cursor position as
        a `Point` instance.
    """

    def __init__(self, text: AnyFormattedText='', style: str='', focusable: FilterOrBool=False, key_bindings: KeyBindingsBase | None=None, show_cursor: bool=True, modal: bool=False, get_cursor_position: Callable[[], Point | None] | None=None) -> None:
        self.text = text
        self.style = style
        self.focusable = to_filter(focusable)
        self.key_bindings = key_bindings
        self.show_cursor = show_cursor
        self.modal = modal
        self.get_cursor_position = get_cursor_position
        self._content_cache: SimpleCache[Hashable, UIContent] = SimpleCache(maxsize=18)
        self._fragment_cache: SimpleCache[int, StyleAndTextTuples] = SimpleCache(maxsize=1)
        self._fragments: StyleAndTextTuples | None = None

    def __repr__(self) -> str:
        return f'{self.__class__.__name__}({self.text!r})'

    def _get_formatted_text_cached(self) -> StyleAndTextTuples:
        """
        Get fragments, but only retrieve fragments once during one render run.
        (This function is called several times during one rendering, because
        we also need those for calculating the dimensions.)
        """
        return self._fragment_cache.get(0, lambda: to_formatted_text(self.text, self.style))

    def preferred_width(self, max_available_width: int) -> int:
        """
        Return the preferred width for this control.
        That is the width of the longest line.
        """
        text = fragment_list_to_text(self._get_formatted_text_cached())
        lines = text.splitlines()
        if not lines:
            return 0
        return max(get_cwidth(line) for line in lines)

    def preferred_height(self, width: int, max_available_height: int, wrap_lines: bool, get_line_prefix: GetLinePrefixCallable | None) -> int | None:
        """
        Return the preferred height for this control.
        """
        content = self.create_content(width, None)
        height = 0
        for i in range(content.line_count):
            height += content.get_height_for_line(i, width, get_line_prefix)
            if height >= max_available_height:
                return max_available_height
        return height

    def mouse_handler(self, mouse_event: MouseEvent) -> NotImplementedOrNone:
        """
        Handle mouse events.

        (When the fragment list contained mouse handlers and the user clicked on
        on any of these, the matching handler is called. This handler can still
        return `NotImplemented` in case we want the
        :class:`~prompt_toolkit.layout.Window` to handle this particular
        event.)
        """
        if mouse_event.event_type == MouseEventType.MOUSE_UP:
            fragments = self._get_formatted_text_cached()
            x = mouse_event.position.x
            y = mouse_event.position.y
            
            # Find the fragment corresponding to the mouse position
            for style, text, handler in fragments:
                if len(text) > x and y == 0:
                    if handler is not None:
                        return handler(mouse_event)
                    return NotImplemented
                x -= len(text)
                if x < 0:
                    y -= 1
                    x = len(text) + x
        
        return NotImplemented

class DummyControl(UIControl):
    """
    A dummy control object that doesn't paint any content.

    Useful for filling a :class:`~prompt_toolkit.layout.Window`. (The
    `fragment` and `char` attributes of the `Window` class can be used to
    define the filling.)
    """

class _ProcessedLine(NamedTuple):
    fragments: StyleAndTextTuples
    source_to_display: Callable[[int], int]
    display_to_source: Callable[[int], int]

class BufferControl(UIControl):
    """
    Control for visualizing the content of a :class:`.Buffer`.

    :param buffer: The :class:`.Buffer` object to be displayed.
    :param input_processors: A list of
        :class:`~prompt_toolkit.layout.processors.Processor` objects.
    :param include_default_input_processors: When True, include the default
        processors for highlighting of selection, search and displaying of
        multiple cursors.
    :param lexer: :class:`.Lexer` instance for syntax highlighting.
    :param preview_search: `bool` or :class:`.Filter`: Show search while
        typing. When this is `True`, probably you want to add a
        ``HighlightIncrementalSearchProcessor`` as well. Otherwise only the
        cursor position will move, but the text won't be highlighted.
    :param focusable: `bool` or :class:`.Filter`: Tell whether this control is focusable.
    :param focus_on_click: Focus this buffer when it's click, but not yet focused.
    :param key_bindings: a :class:`.KeyBindings` object.
    """

    def __init__(self, buffer: Buffer | None=None, input_processors: list[Processor] | None=None, include_default_input_processors: bool=True, lexer: Lexer | None=None, preview_search: FilterOrBool=False, focusable: FilterOrBool=True, search_buffer_control: None | SearchBufferControl | Callable[[], SearchBufferControl]=None, menu_position: Callable[[], int | None] | None=None, focus_on_click: FilterOrBool=False, key_bindings: KeyBindingsBase | None=None):
        self.input_processors = input_processors
        self.include_default_input_processors = include_default_input_processors
        self.default_input_processors = [HighlightSearchProcessor(), HighlightIncrementalSearchProcessor(), HighlightSelectionProcessor(), DisplayMultipleCursors()]
        self.preview_search = to_filter(preview_search)
        self.focusable = to_filter(focusable)
        self.focus_on_click = to_filter(focus_on_click)
        self.buffer = buffer or Buffer()
        self.menu_position = menu_position
        self.lexer = lexer or SimpleLexer()
        self.key_bindings = key_bindings
        self._search_buffer_control = search_buffer_control
        self._fragment_cache: SimpleCache[Hashable, Callable[[int], StyleAndTextTuples]] = SimpleCache(maxsize=8)
        self._last_click_timestamp: float | None = None
        self._last_get_processed_line: Callable[[int], _ProcessedLine] | None = None

    def __repr__(self) -> str:
        return f'<{self.__class__.__name__} buffer={self.buffer!r} at {id(self)!r}>'

    @property
    def search_state(self) -> SearchState:
        """
        Return the `SearchState` for searching this `BufferControl`. This is
        always associated with the search control. If one search bar is used
        for searching multiple `BufferControls`, then they share the same
        `SearchState`.
        """
        if isinstance(self._search_buffer_control, SearchBufferControl):
            return self._search_buffer_control.searcher_search_state
        elif callable(self._search_buffer_control):
            return self._search_buffer_control().searcher_search_state
        else:
            return SearchState()

    def preferred_width(self, max_available_width: int) -> int | None:
        """
        This should return the preferred width.

        Note: We don't specify a preferred width according to the content,
              because it would be too expensive. Calculating the preferred
              width can be done by calculating the longest line, but this would
              require applying all the processors to each line. This is
              unfeasible for a larger document, and doing it for small
              documents only would result in inconsistent behavior.
        """
        return None  # No preferred width

    def _get_formatted_text_for_line_func(self, document: Document) -> Callable[[int], StyleAndTextTuples]:
        """
        Create a function that returns the fragments for a given line.
        """
        def get_formatted_text_for_line(lineno: int) -> StyleAndTextTuples:
            line = document.lines[lineno]
            return self.lexer.lex_document(document)(lineno, line)
        
        return get_formatted_text_for_line

    def _create_get_processed_line_func(self, document: Document, width: int, height: int) -> Callable[[int], _ProcessedLine]:
        """
        Create a function that takes a line number of the current document and
        returns a _ProcessedLine(processed_fragments, source_to_display, display_to_source)
        tuple.
        """
        get_formatted_text_for_line = self._get_formatted_text_for_line_func(document)
        
        def get_processed_line(lineno: int) -> _ProcessedLine:
            fragments = get_formatted_text_for_line(lineno)
            processors = self._get_processors()
            
            transform_input = TransformationInput(
                fragments,
                document,
                width,
                lineno
            )
            
            def source_to_display(i: int) -> int:
                return i  # Identity function for now
            
            def display_to_source(i: int) -> int:
                return i  # Identity function for now
            
            processed_fragments = fragments
            for processor in processors:
                processed_fragments = processor.apply_transformation(transform_input)
            
            return _ProcessedLine(processed_fragments, source_to_display, display_to_source)
        
        return get_processed_line

    def create_content(self, width: int, height: int, preview_search: bool=False) -> UIContent:
        """
        Create a UIContent.
        """
        buffer = self.buffer
        document = buffer.document
        
        get_processed_line = self._create_get_processed_line_func(document, width, height)
        
        def get_line(i: int) -> StyleAndTextTuples:
            return get_processed_line(i).fragments
        
        cursor_position = buffer.cursor_position
        cursor_line, cursor_column = document.translate_index_to_position(cursor_position)
        
        return UIContent(
            get_line=get_line,
            line_count=document.line_count,
            cursor_position=Point(x=cursor_column, y=cursor_line),
            menu_position=self.menu_position() if callable(self.menu_position) else self.menu_position,
            show_cursor=True
        )

    def mouse_handler(self, mouse_event: MouseEvent) -> NotImplementedOrNone:
        """
        Mouse handler for this control.
        """
        buffer = self.buffer
        position = mouse_event.position
        
        if mouse_event.event_type == MouseEventType.MOUSE_UP:
            # Focus buffer when clicked.
            if self.focus_on_click():
                get_app().layout.current_control = self
            
            # Handle double clicks
            if (
                mouse_event.button == MouseButton.LEFT
                and self._last_click_timestamp
                and time.time() - self._last_click_timestamp < 0.5
            ):
                self._handle_double_click(position)
            else:
                self._handle_single_click(position)
            
            self._last_click_timestamp = time.time()
            
            return None
        elif mouse_event.event_type == MouseEventType.SCROLL_DOWN:
            self._scroll_down(position)
            return None
        elif mouse_event.event_type == MouseEventType.SCROLL_UP:
            self._scroll_up(position)
            return None
        
        return NotImplemented

    def get_key_bindings(self) -> KeyBindingsBase | None:
        """
        When additional key bindings are given. Return these.
        """
        return self.key_bindings

    def get_invalidate_events(self) -> Iterable[Event[object]]:
        """
        Return the Window invalidate events.
        """
        yield self.buffer.on_text_changed
        yield self.buffer.on_cursor_position_changed
        
        if self.search_buffer_control:
            search_buffer = (
                self.search_buffer_control.buffer
                if isinstance(self.search_buffer_control, BufferControl)
                else self.search_buffer_control().buffer
            )
            yield search_buffer.on_text_changed
        
        # Yield all events that could possibly change the content of this
        # control.
        yield get_app().on_color_depth_changed
        yield get_app().on_style_changed

class SearchBufferControl(BufferControl):
    """
    :class:`.BufferControl` which is used for searching another
    :class:`.BufferControl`.

    :param ignore_case: Search case insensitive.
    """

    def __init__(self, buffer: Buffer | None=None, input_processors: list[Processor] | None=None, lexer: Lexer | None=None, focus_on_click: FilterOrBool=False, key_bindings: KeyBindingsBase | None=None, ignore_case: FilterOrBool=False):
        super().__init__(buffer=buffer, input_processors=input_processors, lexer=lexer, focus_on_click=focus_on_click, key_bindings=key_bindings)
        self.searcher_search_state = SearchState(ignore_case=ignore_case)
